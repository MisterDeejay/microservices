Q1. What is the proc / cons of using microservices, from your point of view?
The use of microservices are one of the more recent advancements seen in web development architecture developed as a response to the proliferation of monolith applications seen at many companies containing all code connected to the business, with one database and many subsystems holding a number of various responsibilities. By definition, the micro service design pattern results in a collection of loosely coupled services, with the division between each service being based on functionality that allows the developers to scale services separately.

Traditionally, functionality between each service is exposed through a REST API and messages can exchanged through HTTP and JSON. The collection of microservices results in the entire application, and ideally the individual microservices can be abstracted away when referring to the application as a whole. One benefit of this approach is that each service can now have not just its own data source and the entire tech stack can be customized completely separating different domains and giving you the flexibility to use the right set of tools for each microservice.  This promotes weak coupling between subsystems and can reduce dependencies.

Another advantage of such an approach are an increase in modularization and independence of separate subsystems. All services can be independently deployed giving DevOps and more granular approach to support the application as a whole. This gives more control over what parts of the app sit on what types of server and gives increased control over the ability to scale only the "high use" services, rather than having to scale the entire monolith to support the subsystem that is most used. Ultimately, this can result in cost savings for the business.

Each service can now be tested, built and deployed on its own. This results in the added benefit of easier and more frequent deployments now that the test suite is smaller. This speeds up and simplifies the build/release workflow and gives the team faster feedback from the CI server after commits. Now that the release of one subsystem (now its own service) is no longer blocked by another subsystem, engineering department can break into small teams that can work in parallel increasing productivity. This parallel development means less team dependency which again results in faster development.

Continuous delivery becomes easier and deployment risk should go down now that releases are tied to smaller services (i.e. a failed deployment may not result in the entire application failing). Higher test coverage should be more easily achieved as a result of the independence of the services and the smaller number of coarsely-grained REST calls rather than a larger number of in-process method calls. If the services are built in a resilient manner, with ways to handle network failure and/or dropped messages etc, the application should have a smaller downtime percentage. Finally, the re-usability of difference services is now possible, keeping the application DRY.

Of course, all design pattern are not without their cons, and most of the problems associated with the microservice design pattern center around dealing with distributed systems. That, of course, includes increased effort around operations, deployment and monitoring now that you have multiple service that require their own separate deployment unit and have to tested, released and monitored all on their own, culminating in an increase in configuration management.

Separate services also means more points of failure and potentially unsafe communication now that it's being done through HTTP over REST calls rather than through internal API calls. With communication over a network comes the possibility of network failure and now the software has to be built with this in mind and must be resilient in order to handle network loss or failures.

In addition to reduced transaction safety over networks, you also have to worry about unsafe distributed communication as handling callbacks becomes more difficult. What happens when a transaction rolls back, but the downstream microservice has already been notified? Now that messages are being sent asynchronously over a network, your code must be built with that in mind.

Microservice architecture also suffers from a performance hit to the the network overhead and HTTP (de)serialization. Data redundancy and data synchronization practices like caching and sharding, however, can help to minimize the performance loss. Refactoring can also be more difficult, particularly when moving code between microservices. And finally, you have to make sure to keep dependencies compatible after updating services, something you did not have to worry about when all your code was contained in a single monolith application.

Q2. Please describe steps to split monolithic application into the microservices

When splitting a monolithic application, the number one driver is decoupling capabilities to release them independently. The first step in this process is to identify the code for separation. You want to start with the edge services that are the most decoupled. This identification can be done through static analysis tools, like RubyCritic, to find naturally isolated code. Other good candidates for service separation are:
1) subsystems that require the fewest number of changes to client facing applications,
2) subsystems that don't need a data source, and
3) subsystems that are candidates for reusability and extraction versus rewrite and retire.

Starting this way is advantageous for a few reasons; by starting with the subsystems that are most decoupled, you are able to quickly test and optimize for your delivery validation. It also gives less experienced team members some experience with relatively easy subsystems by building out the smallest piece required to deliver an independently deployable secure service that exposes a self-serviceable API.

Before the creation of the new service can actually start, it is important to first set up the deployment environment, the CI pipeline and the debugging/montioring/logging architecture. That way, there is no lag time between service completion and the go-live date.

During this process, it's important to keep in mind that the ultimate goal is to always move in the direction of removing dependencies from the monolithic application. In cases where avoiding service dependencies means adding calls back to the monolith, it becomes necessary to expose a new API layer.

Once these subsystems have been successfully separated to their own services and the approach has been validated, the more difficult task of moving out services that have user facing components or that need a separate data source can be attempted. All services should be set up as facade services to provide developer friendly APIs and shared data between services should remain in one schema/storage system. Overall, the goal should always be to move from the macro to micro and migrating in atomic evolution steps. In other words, begin with an analysis of the entire app, come up with a plan of attack, then begin moving the smallest piece first, making sure that every time a decision is made to move some code into its own separate service, it is an all or nothing move.
